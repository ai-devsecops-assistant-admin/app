#!/usr/bin/env bash

# Pre-commit hook for Platform Governance
# Runs validation checks before allowing commits

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Running pre-commit checks...${NC}"

# Track if any check fails
FAIL=0

# Get list of staged files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)
STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.ts$' || true)
STAGED_YAML_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.yaml$\|\.yml$' || true)
STAGED_SH_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.sh$' || true)

# Check 1: Prevent commits to main/master
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
    echo -e "${RED}✗ Direct commits to main/master are not allowed${NC}"
    echo "  Create a feature branch: git checkout -b feature/your-feature"
    FAIL=1
fi

# Check 2: Gitleaks - Check for secrets
if command -v gitleaks &>/dev/null; then
    echo "Checking for secrets with gitleaks..."
    if ! gitleaks protect --staged --verbose --redact 2>&1 | grep -q "no leaks found"; then
        echo -e "${RED}✗ Secrets detected in commit!${NC}"
        echo "  Review and remove sensitive data before committing"
        FAIL=1
    else
        echo -e "${GREEN}✓ No secrets detected${NC}"
    fi
else
    echo -e "${YELLOW}⚠ gitleaks not installed, skipping secret scan${NC}"
fi

# Check 3: Go formatting and linting
if [ -n "$STAGED_GO_FILES" ]; then
    echo "Checking Go files..."

    # Format check
    if command -v gofmt &>/dev/null; then
        UNFORMATTED=$(echo "$STAGED_GO_FILES" | xargs gofmt -l)
        if [ -n "$UNFORMATTED" ]; then
            echo -e "${RED}✗ Go files not formatted:${NC}"
            echo "$UNFORMATTED"
            echo "  Run: gofmt -w $UNFORMATTED"
            FAIL=1
        else
            echo -e "${GREEN}✓ Go files formatted${NC}"
        fi
    fi

    # Lint check
    if command -v golangci-lint &>/dev/null; then
        if ! echo "$STAGED_GO_FILES" | xargs golangci-lint run --timeout=5m; then
            echo -e "${RED}✗ Go linting failed${NC}"
            FAIL=1
        else
            echo -e "${GREEN}✓ Go linting passed${NC}"
        fi
    else
        echo -e "${YELLOW}⚠ golangci-lint not installed, skipping lint${NC}"
    fi

    # Test check
    if command -v go &>/dev/null; then
        # Extract directories from Go files
        GO_DIRS=$(echo "$STAGED_GO_FILES" | xargs -n1 dirname | sort -u)
        for dir in $GO_DIRS; do
            if [ -f "${dir}/go.mod" ] || git ls-files "${dir}/*_test.go" | grep -q .; then
                echo "Running tests in ${dir}..."
                if ! (cd "$dir" && go test ./... -short); then
                    echo -e "${RED}✗ Go tests failed in ${dir}${NC}"
                    FAIL=1
                fi
            fi
        done
        echo -e "${GREEN}✓ Go tests passed${NC}"
    fi
fi

# Check 4: TypeScript/JavaScript linting
if [ -n "$STAGED_TS_FILES" ]; then
    echo "Checking TypeScript files..."

    # ESLint
    if command -v npx &>/dev/null; then
        if ! echo "$STAGED_TS_FILES" | xargs npx eslint --max-warnings=0; then
            echo -e "${RED}✗ TypeScript linting failed${NC}"
            FAIL=1
        else
            echo -e "${GREEN}✓ TypeScript linting passed${NC}"
        fi
    else
        echo -e "${YELLOW}⚠ npm/npx not available, skipping TS lint${NC}"
    fi
fi

# Check 5: YAML validation
if [ -n "$STAGED_YAML_FILES" ]; then
    echo "Checking YAML files..."

    if command -v yamllint &>/dev/null; then
        if ! echo "$STAGED_YAML_FILES" | xargs yamllint -d relaxed; then
            echo -e "${RED}✗ YAML validation failed${NC}"
            FAIL=1
        else
            echo -e "${GREEN}✓ YAML files valid${NC}"
        fi
    else
        # Fallback to basic syntax check with Python
        if command -v python3 &>/dev/null; then
            for file in $STAGED_YAML_FILES; do
                if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
                    echo -e "${RED}✗ Invalid YAML: $file${NC}"
                    FAIL=1
                fi
            done
            if [ $FAIL -eq 0 ]; then
                echo -e "${GREEN}✓ YAML files valid${NC}"
            fi
        fi
    fi

    # Check Kubernetes manifests naming convention
    K8S_YAML=$(echo "$STAGED_YAML_FILES" | grep -E 'deploy/|ops/' || true)
    if [ -n "$K8S_YAML" ] && command -v conftest &>/dev/null; then
        echo "Validating Kubernetes naming conventions..."
        if ! echo "$K8S_YAML" | xargs conftest test -p .config/conftest/policies/; then
            echo -e "${RED}✗ Naming convention violations detected${NC}"
            FAIL=1
        else
            echo -e "${GREEN}✓ Naming conventions validated${NC}"
        fi
    fi
fi

# Check 6: Shell script validation
if [ -n "$STAGED_SH_FILES" ]; then
    echo "Checking shell scripts..."

    if command -v shellcheck &>/dev/null; then
        if ! echo "$STAGED_SH_FILES" | xargs shellcheck -x; then
            echo -e "${RED}✗ Shell script validation failed${NC}"
            FAIL=1
        else
            echo -e "${GREEN}✓ Shell scripts validated${NC}"
        fi
    else
        echo -e "${YELLOW}⚠ shellcheck not installed, skipping validation${NC}"
    fi

    # Check all scripts are executable
    for script in $STAGED_SH_FILES; do
        if [ ! -x "$script" ]; then
            echo -e "${RED}✗ Script not executable: $script${NC}"
            echo "  Run: chmod +x $script"
            FAIL=1
        fi
    done
fi

# Check 7: Commit message format
COMMIT_MSG_FILE=$(git rev-parse --git-dir)/COMMIT_EDITMSG
if [ -f "$COMMIT_MSG_FILE" ]; then
    COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

    # Check for Conventional Commits format
    if ! echo "$COMMIT_MSG" | grep -qE '^(feat|fix|docs|style|refactor|test|chore|security)(\(.+\))?: .+'; then
        echo -e "${YELLOW}⚠ Commit message should follow Conventional Commits format${NC}"
        echo "  Example: feat(api): add naming validation endpoint"
    fi
fi

# Check 8: No large files
echo "Checking for large files..."
LARGE_FILES=$(git diff --cached --name-only --diff-filter=ACM | xargs -I{} sh -c 'test $(stat -f%z "{}" 2>/dev/null || stat -c%s "{}") -gt 1048576 && echo {}' || true)
if [ -n "$LARGE_FILES" ]; then
    echo -e "${RED}✗ Large files detected (>1MB):${NC}"
    echo "$LARGE_FILES"
    echo "  Consider using Git LFS or reducing file size"
    FAIL=1
fi

# Final result
echo ""
if [ $FAIL -eq 1 ]; then
    echo -e "${RED}================================${NC}"
    echo -e "${RED}Pre-commit checks FAILED${NC}"
    echo -e "${RED}================================${NC}"
    echo ""
    echo "Fix the issues above before committing."
    echo "To bypass these checks (NOT RECOMMENDED), use:"
    echo "  git commit --no-verify"
    exit 1
else
    echo -e "${GREEN}================================${NC}"
    echo -e "${GREEN}All pre-commit checks PASSED!${NC}"
    echo -e "${GREEN}================================${NC}"
    exit 0
fi
